#!/usr/bin/env bash
#
# Colony Progress Parser - Makes stream-json output human-readable
#
# Usage: claude -p "..." --output-format stream-json --verbose | colony-progress-parser
#
# This script parses the JSON stream from `claude -p --output-format stream-json`
# and displays a human-readable progress view.
#

set -euo pipefail

# Colors
if [[ -t 1 ]]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[0;33m'
  BLUE='\033[0;34m'
  CYAN='\033[0;36m'
  DIM='\033[2m'
  NC='\033[0m'
else
  RED='' GREEN='' YELLOW='' BLUE='' CYAN='' DIM='' NC=''
fi

# Parse each line of JSON
while IFS= read -r line; do
  # Skip empty lines
  [[ -z "$line" ]] && continue

  # Try to parse as JSON
  if ! type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null); then
    continue
  fi

  case "$type" in
    system)
      subtype=$(echo "$line" | jq -r '.subtype // empty')
      if [[ "$subtype" == "init" ]]; then
        model=$(echo "$line" | jq -r '.model // "unknown"')
        echo -e "${CYAN}üöÄ Session started (model: $model)${NC}"
      fi
      ;;

    assistant)
      # Check for tool use
      content_type=$(echo "$line" | jq -r '.message.content[0].type // empty')

      if [[ "$content_type" == "tool_use" ]]; then
        tool_name=$(echo "$line" | jq -r '.message.content[0].name // empty')
        tool_input=$(echo "$line" | jq -r '.message.content[0].input // {}' 2>/dev/null)

        case "$tool_name" in
          Task)
            subagent=$(echo "$tool_input" | jq -r '.subagent_type // "unknown"')
            desc=$(echo "$tool_input" | jq -r '.description // ""')
            echo -e "${BLUE}üîß Spawning: $subagent${NC} ${DIM}($desc)${NC}"
            ;;
          Bash)
            cmd=$(echo "$tool_input" | jq -r '.command // ""' | head -c 60)
            echo -e "${YELLOW}$ $cmd...${NC}"
            ;;
          Read)
            file=$(echo "$tool_input" | jq -r '.file_path // ""' | sed 's|.*/||')
            echo -e "${DIM}üìñ Reading: $file${NC}"
            ;;
          Write|Edit)
            file=$(echo "$tool_input" | jq -r '.file_path // ""' | sed 's|.*/||')
            echo -e "${GREEN}‚úèÔ∏è  Writing: $file${NC}"
            ;;
          Grep|Glob)
            pattern=$(echo "$tool_input" | jq -r '.pattern // ""')
            echo -e "${DIM}üîç Searching: $pattern${NC}"
            ;;
          *)
            echo -e "${DIM}üîß Tool: $tool_name${NC}"
            ;;
        esac

      elif [[ "$content_type" == "text" ]]; then
        text=$(echo "$line" | jq -r '.message.content[0].text // empty')
        if [[ -n "$text" ]]; then
          # Truncate long text
          if [[ ${#text} -gt 200 ]]; then
            text="${text:0:200}..."
          fi
          # Check for important markers
          if echo "$text" | grep -q "MILESTONE_COMPLETE"; then
            echo -e "${GREEN}‚úì $text${NC}"
          elif echo "$text" | grep -q "MILESTONE_STUCK"; then
            echo -e "${RED}‚úó $text${NC}"
          elif echo "$text" | grep -q "DONE\|PASS"; then
            echo -e "${GREEN}$text${NC}"
          elif echo "$text" | grep -q "FAIL\|STUCK\|ERROR"; then
            echo -e "${RED}$text${NC}"
          else
            echo -e "${DIM}$text${NC}"
          fi
        fi
      fi
      ;;

    tool_result)
      # Tool results - usually verbose, skip unless error
      is_error=$(echo "$line" | jq -r '.is_error // false')
      if [[ "$is_error" == "true" ]]; then
        error=$(echo "$line" | jq -r '.content // "Unknown error"' | head -c 100)
        echo -e "${RED}‚ùå Error: $error${NC}"
      fi
      ;;

    result)
      subtype=$(echo "$line" | jq -r '.subtype // empty')
      duration=$(echo "$line" | jq -r '.duration_ms // 0')
      duration_sec=$((duration / 1000))
      cost=$(echo "$line" | jq -r '.total_cost_usd // 0')

      if [[ "$subtype" == "success" ]]; then
        echo -e "${GREEN}‚úÖ Complete (${duration_sec}s, \$$cost)${NC}"
      else
        echo -e "${RED}‚ùå Failed (${duration_sec}s)${NC}"
      fi
      ;;

    *)
      # Unknown type - skip
      ;;
  esac
done
